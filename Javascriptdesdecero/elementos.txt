● .click(): facilita la ejecución de una función cuando se hace clic sobre un objeto.

● .setTimeout(): facilita la ejecución de una función.

● AJAX: tecnología desarrollada en JavaScript para interactuar con un servidor. Permite mejorar la velocidad y usabilidad, al hacer que se cargue solo lo necesario de cada página.

● Alert(): anuncio de alerta mediante mensaje.

● Array: tipo especial de variable que puede contener más de un valor al mismo tiempo. No es necesario que los valores sean todos del mismo tipo. Los elementos en un array se numeran con índices, que comienzan desde 0.

● Árbol DOM: plantilla de estructura de una página web.

● Booleano: tipo de variable que está conformada por dos únicos valores posibles: true/false.

● Consola: herramienta disponible en todos los navegadores que sirve para la depuración del código.

● Depuración del código (debug): mantenimiento y corrección de un código fuente.

● DOM (Document Object Model): API de programación para documentos HTML. Proporciona un conjunto de objetos que permiten que JavaScript interactúe con elementos HTML y los manipule.

● Evento: acción que permite la interactividad y que sucede en una página web. Puede ser un clic que realiza el usuario, presión en una tecla, y otras.

● Framework: colección de herramientas y librerías que simplifican el desarrollo de aplicaciones en JavaScript.

● Función: es un bloque de código reutilizable que realiza una tarea específica cuando se lo llama. Se define con la palabra reservada function.

● Id: significa la mención que identifica un elemento del árbol DOM.

● if-else: una estructura de control que sirve para tomar decisiones. Permite ejecutar cierto código si se cumple una condición.

● Img: insertar imágenes en la web.

● JavaScript (JS): es un lenguaje de programación de alto nivel que se utiliza en el desarrollo web para generar interactividad en las páginas web como: validación de formularios, interactuar con el Document Object Model (DOM), generar sliders y otras funcionalidades. También sirve para realizar aplicaciones móviles, juegos, IoT (Internet de las cosas), aplicaciones de Backend y APIs, entre otros usos. para generar interactividad en las páginas web.

● JQuery: es una librería multiplataforma de JavaScript que sirve para actualizar un sitio web y crear plugins, eventos, animaciones y apps.

● Manejador de eventos: función asignada a un evento y, generalmente, asociada a un elemento HTML.

● Método: es una función que está asociada a un objeto y se almacena como una de sus propiedades. Permiten que el objeto realice acciones o cálculos.

● New: permite crear nueva solicitud de un objeto mediante un constructor.

● nombreObjeto: permite ver las propiedades del objeto en la consola.

● nombreObjeto.otraPropiedad = function() {}: facilita la asignación de función al objeto

● nombreObjeto.propiedad: permite mostrar el valor de la propiedad del objeto.

● nombreObjeto.propiedad = valor : facilita la asignación de valor a la propiedad.

● Objeto: en JavaScript, un objeto es una entidad que almacena valores relacionados. Sirven para modelar y representar elementos y su comportamiento en el código. Pueden contener propiedades y métodos. Los métodos permiten que el objeto realice acciones u operaciones matemáticas.

● Palabras reservadas: son las que se utilizan para elaborar las sentencias de JavaScript de manera exclusiva. Las palabras son: Break, Case, Catch, Continue, Default, Delete, Do, Else, Finally, For, Function, If, In, Instanceof, New, Return, Switch, This, Throw, Try, Typeof, Var, Void, While, With.

● Return: facilita la obtención de un valor al salir de un contexto.

● Script: también conocido como “guión”, trata de los programas, aplicaciones o códigos realizados con el lenguaje de programación JavaScript.

● Sentencia: son las instrucciones de un script.

● Src: señal de ubicación de Script o imagen dentro del navegador.

● This: para señalar el objeto en el que se está trabajando.

● Var: palabra usada para definir una variable.

● Variables: se utilizan en los lenguajes de programación para almacenar valores.

● Implementar JS de manera externa:
Para crear un archivo JavaScript, antes de comenzar a escribir la lógica de las aplicaciones, se debe contar con un documento HTML. Los archivos JS se referencian dentro del encabezado <head> de los documentos HTML. El atributo defer, que acompaña al archivo JS, solo es necesario incluirlo cuando interactuemos desde JS con elementos HTML. Siempre conviene crear subcarpetas dedicadas, para mantener ordenado los diferentes tipos de archivos que conforman a un proyecto. Para introducirlo en HTML, se debe utilizar el siguiente codigo
<script defender src="y la ruta donde se encuentra"></script>

● JavaScript "console" es un objeto, nativo de este lenguaje, que cuenta con una serie de metodos incorporados que permite scar provecho al momento de analizar elcodigo o comportamientode estas aplicaciones. La mayoria de sus metdos arrojan resultados en la pestaña Console de las herramientas para el desarrollador (DevTools). 
Existen estos cuatro metodos de "console":
● console.log(): Permite visualizar un mensaje definido en la consola de JS. Este texto puede provenir de un texto definido manualmente por nostros, o desde el valor contenido en una variable o constante
● console.warn(): Visualiza tambien un mensaje en la Consola de JS con un énfasis de color refiriendo a un tipo de mensaje de advertencia. A su vez, incorpora el icono de alerta, para que le prestemos atencion a mismo al identificarlo en la consola de JS
● console.error(): Visualiza tambien un mensaje en la Consola de JS con un énfasis de color refiriendo a un tipo de mensaje de error
● console.table(): Es de gran utilidad para representar en pantalla datos tabulares, por ejemplo, cuando se trabaja con arrays de elementos, arrays de objetos, u objetos literales, que contienen multiples datos, son mejor representados por este metodo que por console.log()
 
 // VARIABLES 

Una variable es un elemento que permite almacenar o guardar información para ser utilizada nuevamente. Cuando se incorporan variables en una aplicación web, y esta se ejecuta, reserva un espacio en la memoria de la computadora o dispositivo, donde deja disponible la variable con el valor que se le haya asignado.
Declaración de las variables. Las variables se declaran anteponiendo la palabra reservada "let", seguido del nombre “identificativo” que le daremos a la variable. Este nombre debe identificar su valor almacenado. Para asignar un valor, en el mismo momento en que la declaramos, se agrega el operador de asignación igual "=" y luego el valor deseado.
Por ejemplo: 
            let nombreCompleto
            let empresa= "EducacionIT"

En JavaScript, se pueden declarar variables con las palabras clave var y let, según el alcance que se desea definir para esa variable. A partir de la versión ES6 (año 2015), se insiste en priorizar el uso de let para declarar variables, ya que ofrece un alcance de bloque más claro y menos propenso a errores. Si tu propósito futuro es trabajar en el universo del desarrollo web frontend o backend con el lenguaje JavaScript, enfócate en declarar las variables, siempre, mediante let. Si declaramos una variable con un valor inicial, y luego se necesita cambiar el valor por otro, simplemente se debe definir el nombre de la variable seguida del signo = y el nuevo valor que deseamos almacenar en ella. Con esto, la variable cambió su valor inicial, y se podrá utilizar su nuevo valor, en cualquier parte del programa donde se requiera.

Reglas para nombrar una variable en JavaScript:
● Los nombres de variables pueden contener letras, números, _ (underscore) y signo de dólar ($).
● No pueden comenzar con un número.
● Deben comenzar en minúsculas.
● Los nombres son case sensitive (no es lo mismo A que a)

En JavaScript se estila declarar cada variable o constante utilizando una palabra, en minúsculas, que describa el tipo de datos que almacena. Es posible usar dos o más palabras, en aquellos casos donde una sola no alcance para describir el valor que se almacenará. Cuando se combinen palabras usando el formato camelCase se debe contemplar que, cada palabra adicional tenga su primera inicial en mayúsculas.

//CONSTANTES

Las constantes, son una especie de variable que también ocupan un espacio en memoria, y permiten almacenar un valor específico para ser utilizado dentro de nuestra aplicación web. Se declaran al anteponer la palabra reservada const. A diferencia de una variable declarada con let, las constantes no permiten cambiar el valor que se le haya asignado. Tal como su nombre lo indica, el valor inicial que le asignemos será “un valor constante”, durante todo el ciclo de vida de nuestra aplicación. Si intentamos cambiar su valor predefinido, la constante arrojará un error y no realizará el cambio forzado.
Por ejemplo:
const usuarioID= "Pepitoperez"
const empresa= "EducacionIT"
const metodoDePago= "Tarjeta de debito"

¿Cuándo utilizarlas?
Las constantes se deben utilizar en escenarios donde sea necesario guardar un valor y este no deba cambiar.

Tipos de datos: 
Se define como tipado de datos, a la forma de poder crear variables que respeten una estructura específica de la información que guarden. JavaScript posee lo que se denomina un tipado débil de datos, por lo tanto no es necesario definir qué tipo de datos posee una variable y podrá cambiar durante el ciclo de vida de la aplicación web.

● string :Almacena datos del tipo cadena de caracteres. Puede ser una cadena alfabética o alfanumérica, incluyendo caracteres extendidos.
● number: Almacena un dato numérico. El mismo puede ser entero o de punto flotante (poseer decimales). Para este último punto, JavaScript maneja los decimales utilizando el punto (.) como separador decimal.
● boolean: Un tipo de dato estándar para definir valores verdaderos (TRUE), o valores falsos (FALSE).
● object: Un tipo de dato propio de los objetos en JS. Se utiliza tanto para los objetos literales como también para objetos del sistema, instanciados a partir de una clase, y también para un array de objetos.
● array: Un tipo de dato propio de los array o colecciones de elementos o de objetos. En JS es muy utilizado y es la base fundamental de conceptos avanzados en este lenguaje de programación.
● NaN: La propiedad global NaN es un valor que representa Not-A-Number. Por ejemplo, si declaramos una variable sin valor, y la multiplicamos por un número, su resultado será NaN.
● undefined: La propiedad global undefined representa el valor primitivo undefined. Una variable a la que no se le ha asignado valor es de tipo undefined

string 
Las variables del tipo string:
● Permiten almacenar valores también denominados como cadenas de texto.
● Pueden ser alfanuméricas, y contener cualquier tipo de dato.
● Al declararlas, se debe encerrar el valor asignado entre comillas (simples '' o comillas dobles "").

number 
Las variables del tipo number:
● Permiten almacenar valores numéricos. Estos pueden ser del tipo entero, o con decimales.
● En la definición de un valor numérico con decimales, se debe utilizar el punto “.” como separador.
● No se utiliza separador de miles, y se declaran valores sin encerrarlos entre comillas

boolean
Las variables del tipo boolean:
● Permiten almacenar valores booleanos (TRUE o FALSE). Son los únicos dos valores posibles en un entorno booleano.
● Estos valores representan un dato, cuando este es verdadero, o es falso

array
● Un array es un tipo de variable que permite almacenar múltiples valores en lugar de uno solo. Este tipo de dato facilita la agrupación de valores que tienen algo en común.
● De esta forma, se pueden concentrar todos en un único lugar. Esto hará que sean mucho más fácil de acceder. Los arrays tienen un poder y un valor importante en la construcción cotidiana de aplicaciones JavaScript.
ej: const frutas= ['Pera', 'Banana', 'Manzana', 'Naranja']

NaN
Las variables del tipo NaN:
● Definen un valor que significa Not-A-Number. Esto ocurre, por ejemplo, cuando tenemos una variable declarada pero no inicializada (no se le asignó un valor), e intentamos multiplicarla por un valor numérico.

// Propiedades y métodos en variables

Cuando se crea una variable, esta recibe, de forma predeterminada, una serie de métodos. Estos métodos, permiten trabajar sobre el valor de la variable de acuerdo a la necesidad que debemos aplicar en el programa. Los métodos disponibles para una variable del tipo String, son propios de este tipo de dato. Existen muchísimos métodos. Ayudan a interactuar con los datos de la variable, de forma precisa; leen, convierten o transforman el valor almacenado según la necesidad.
Por ejemplo: 
            let nombre ='EducacionIT';
            ● nombre.lenght //devuelve el total de caracteres
            ● nombre.at(2) //devuelve el caracter en dicha posicion
            ● nombre.trim() //elimina espacion agregados al inicio o final 
            ● nombre.toUpperCase() //convierte el texto a mayusculas
            ● nombre.toLowerCase() //convierte el texto a minusculas

Los métodos para variables que almacenan valores del tipo number ayudan a trabajar mejor el formato de cada número, de acuerdo a la necesidad en el momento de almacenarlos, o de representarlos en pantalla
por ejemplo: 
            let numero = 2103; 
            ● numero.toPrecision(6)
            ● numero.toFixed(2)
            ● numero.toLocaleString()
            ● numero.toString() 

//Visualizar variables en la consola JS

La consola JS integrada en Developer Tools es una herramienta netamente pensada para depurar aplicaciones. Entre todas las funcionalidades que tiene, permite visualizar el valor de variables y constantes. Para ello, se utiliza el objeto console, integrado a JS, y su método .log(). Dentro de los paréntesis de este método, se referencia la variable y así se puede ver, en la consola JS, qué valor posee almacenado. Como se observa en el ejemplo, es posible visualizar, en la consola JS, el valor de una variable (1), el valor de una variable concatenado (+) con texto estático (2), o también el valor de una variable concatenada con texto estático utilizando una coma en lugar del signo más (3).
por Ejemplo:

            let usuarioLogueado = true
            let empresa= "EducacionIT"
            let nombre= "Pepito Perez"
            let cargo= "CEO McMillian Utilities"
            
            console.log (usuarioLogueado)
            console.log("Nombre: "+ nombre + ", Cargo: " + cargo)
            console.log("Empresa: ", empresa)


// Operadores: introducción
En programación, los operadores son símbolos o palabras clave que se utilizan para realizar manipulaciones sobre valores y variables. Estas operaciones pueden incluir: aritmética, comparación, asignación, lógica, entre otras. Los operadores son fundamentales para construir expresiones y sentencias. Al combinar variables, constantes y valores literales con operadores, es posible: realizar cálculos, evaluar condiciones y realizar diversas acciones en un programa.

Asignación, incremento y decremento
● El operador de asignación se utiliza para guardar un valor en una variable. Ya lo hemos utilizado previamente. Veamos el ejemplo contiguo:
        let iva= 1.21

● El operador de incremento se indica mediante el prefijo ++. Incrementa la variable en una unidad, tal como se muestra en la segunda imagen.
● El operador de decremento se indica mediante el prefijo --. Decrementa la variable en una unidad.
        let numero= 12
        ++numero
        console.log('Valor de la variable numero', numero);

Operadores matemáticos
JavaScript permite realizar operaciones matemáticas:
● suma (+),
● resta (-),
● multiplicación (*) y
● división (/).
Veamos algunos ejemplos en las diapositivas a continuación La definición de valores numéricos con decimales no utiliza separador de miles, y usa punto (.) como separador decimal, por ejemplo:
        let haberes= 255340.87
        let bonoTrimestral= 25400
        let totalHaberMes= haberes + bonoTrimestral

        console.log('Haberes a depositar', totalHaberMes)

// Operadores JavaScript orientados a operaciones aritmeticas, u operadores para realizar operaciones aritmeticas basicas:
+ Sumar: en JS, el operador + permite sumar dos valores numéricos. También se utiliza para concatenar valores de variables que pueden ser del tipo string, o combinadas como ser un string y un number.
- Restar: El operador - permite realizar una resta entre dos valores numéricos.
* Multiplicar: El operador * permite realizar una multiplicación entre dos valores numéricos.
/ Dividir: El operador / permite realizar una división entre dos valores numéricos.
% Módulo, o Resto: el operador % permite realizar una división entre dos valores numéricos, pero retornará el módulo, o resto de la división.

Los operadores matemáticos se pueden combinar con el operador de asignación para lograr un resultado más rápido y conciso: En la misma línea de código, se realiza una operación aritmética sobre el valor almacenado en la variable, y se actualiza. Este tipo de operadores matemáticos combinados, es equivalente al uso convencional de los operadores matemáticos y de asignación que vemos en el segundo ejemplo de código. Cualquiera de las dos opciones es totalmente válida y funcional en JavaScript.
        let numero = 9 
        numero +=4 operador de igualdad acumulativa
        numero -= 1 operador de asignacion de resta
        numero *= 1 operador de asignacion de multiplicacion
        numero /= 3 operador de asignacion divisora
        numero %= 4 operador de asignacion de modulo

        let numero = 9
            numero = numero + 4
            numero = numero - 1
            numero = numero * 1
            numero = numero / 3
            numero = numero % 4

Operador + El operador + se utiliza también para concatenar valores del tipo String. Puede ser útil para concatenar dos tipos de datos String en un único valor, o para concatenar un tipo de dato String y un tipo de dato Number, indistintamente del orden en el que se defina. Para esto último, el resultado final siempre será un tipo de dato String, por sobre algún dato numérico
        let numero= 9
        let leyenda = 'El valor de la variable numero, es:'
        let mensaje= leyenda + numero

// Operadores de comparación 
También llamados “operadores relacionales”, se emplean para comparar y establecer la relación entre ellos. Devuelven un valor booleano (true, verdadero, o false, falso) basado en la condición.

=== Operador de comparación igual: permite comparar dos valores específicos, y retornar un valor booleano TRUE, si valorA es igual a valorB, o FALSE, si no lo es.
> Operador de comparación mayor que: permite comparar dos valores específicos, y retornar un valor booleano TRUE, si valorA es mayor que valorB, o FALSE, si no lo es.
>= Operador de comparación mayor o igual que:: permite comparar dos valores específicos, y retornar un valor booleano TRUE, si valorA es mayor, o igual, que valorB, o FALSE, si no lo es.
< Operador de comparación menor que: permite comparar dos valores específicos, y retornar un valor booleano TRUE, si valorA es menor que valorB, o FALSE, si no lo es.
<= Operador de comparación mayor que: permite comparar dos valores específicos, y retornar un valor booleano TRUE, si valorA es menor, o igual, que valorB, o FALSE, si no lo es.
!== Operador de comparación distinto de: permite comparar dos valores específicos, y retornar un valor booleano TRUE, si valorA es distinto de valorB, o FALSE, si son iguales.

Por ejemplo:
let nombre= "EducacionIT"
let empresa = "EDUCACIONIT"

let nroA= 2005
let nroB= 1996

nombre === empresa       //retorna false
nombre != empresa       //retorna true
nroA > nroB             //retorna true
nroA >=nroB             //retorna true
nroA < nroB             //retorna false
nroA <= nroB            //retorna false


// Operadores lógicos

Permiten combinar o invertir valores que se utilizan en comparaciones múltiples.

&&
(AND):
Operador lógico AND: se representa con el símbolo && (doble ampersand), y permite establecer una comparación combinada. Por ejemplo, comparar si valorA es igual a valorB && si valorC es igual a valorD. Si ambas condiciones se cumplen, retornará TRUE como resultado y, si una de las dos condiciones no se cumple, retornará FALSE como resultado.

||
(OR):
Operador lógico OR: se representa con el símbolo || (doble pipe), y permite establecer una comparación combinada / alternativa. Por ejemplo, comparar si valorA es igual a valorB || si valorC es igual a valorD. Si al menos una de estas dos comparaciones se cumple, retornará TRUE como resultado y, si ninguna se cumple, retornará FALSE.

!
(NOT):
Operador lógico NOT: se representa con el carácter ! (signo de exclamación), y se combina generalmente con alguno de los operadores de comparación.

Por ejemplo:
let nombre= "EducacionIT"
let empresa = "EDUCACIONIT"

let nroA= 2005
let nroB= 1996

nombre !== empresa && nroA >nroB     //retorna true
nombre === empresa && nroA >nroB     //retorna false
nombre === empresa || nroA <nroB     //retorna false
empresa !== nombre || nroA >nroB     //retorna true


// CUADROS DE DIALOGO

// Herramientas integradas de JS
JS Ofrece herramientas que se dividen en dos categorias:
● Cuadros de dialogo: son herramientas graficas, nativas del navegador web que permiten interactuar con el usuario. Los cuadros de dialogo se integran dentro del objeto global window. Los cuadros de dialogo son los siguientes:
- alert(): Muestra un cuadro de diálogo llamado alert(), en la página web desde donde se invoca. Se utiliza para mostrar un mensaje al usuario, en forma de mensaje de una sola vía (el usuario no puede interactuar, solo puede pulsar el botón
Aceptar, para cerrarlo).
- confirm(): Esta sentencia muestra un cuadro de diálogo emergente con dos botones (Aceptar - Cancelar). El usuario puede pulsar cualquiera de las dos opciones. Se captura la decisión del usuario y se aplica en la lógica del código.
- prompt(): Esta sentencia muestra un cuadro de diálogo emergente con dos botones (Aceptar - Cancelar), más una caja de texto. A través de esta, el usuario podrá ingresar un dato de cualquier tipo. Lo que allí se ingrese se define como término de entrada, y podrá ser capturado por el código JavaScript y utilizado internamente.

El uso de los cuadros de diálogo prompt() y confirm() requieren que se anteponga a su declaración, una variable o constante dado que, cuando el usuario interactúa con estos cuadros de diálogo, genera una entrada de datos o la elección de un botón, y en ambos casos, los cuadros de diálogo retornarán un valor.

● Herramientas de consola

// ESTRUCTURAS DE CONTRO DE FLUJO
Si solamente se trabaja con operadores y variables, se genera una sucesión de pasos lineales. No se puede decidir si algo se mostrará o no según determinadas circunstancias o, en todo caso, repetir una instrucción varias veces. Para realizar estas secuencias más complejas y con múltiples posibilidades se debe trabajar con estructuras de control de flujo.
● Tipo booleano:
Los tipos de variables de datos booleanos son aquellos conformados únicamente por dos posibles valores: true/false. Un booleano puede ser definido en forma explícita, por ejemplo, al asignar el valor true a una variable.
Recordemos que, por ejemplo, si utilizamos el cuadro de diálogo confirm(), el resultado, que retornará al pulsar alguno de los botones, será verdadero o falso.
Por ejemplo: 

let respuesta = confirm('¿Estas segura/o de continuar?')
A lo que aparecera un recuadro para Aceptar o Cancelar dicha preguntas.

Si quisieramos mostrar la respuesta, deberiamos hacer lo siguiente:
let respuesta = confirm('¿Estas segura/o de continuar')
console.log("La respuesta elegida fue: ", respuesta).
(si el usuario cancelara, el resultado seria "false". Ahora si aceptara, el resultado seria "true")

// Operadores de comparacion:
De igual forma, un valor booleano puede ser el resultante de la comparacion de valores que parten de variables, constantes y otros tantos elementos que cofnorman una aplicacion. (ya mencionados anteriormente)

// Operadores logicos:
Tambien podemos utilizar operadores logicos para genera procesos mas complejos donde decimos, por ejemplo, que un numero es igual o mayor a otro pero tambien que puede cumplir o no con otra condicion.

//ESTRUCTURAS CONDICIONALES

Condicionales
Permiten decisiones acerca de qué sentencias (órdenes) debe ejecutar el programa, en base a una condición / expresión booleana; es decir, si algo retorna true/false.
Se puede decir que a diferencia de los programas que veníamos generando, en este caso, se seguirán una serie de pasos u otra, según el dato de entrada. Por lo tanto, el resultado o dato de salida dependerá del dato de entrada. Los condicionales que explicaremos en las siguientes pantallas son:

● if: el condicional "if" es la estructura mas utilizada al momento de necesitar planteos condicionales para tomar una u otra decision. 
Si la condición se cumple (es decir, si su valor es true)
Se ejecutarán las instrucciones que se encuentran dentro de las llaves de bloque {...}. 
        ej:
                let mostrarMensaje = true;
                if(mostrarMensaje){
                        alert('Hola mundo');
                }
Si la condición no se cumple (es decir, si su valor es false)
No se ejecuta ninguna instrucción contenida en lasllaves de bloque {...} y el programa continúa con laejecución de cualquier otra instrucción oinstrucciones que estén por fuera del condicional:
        ej:
                let mostrarMensaje = false;
                if(mostrarMensaje){
                        alert('No vas a ver este mensaje');
                }

● if, else: En este caso, se fija una alternativa. Algoritmo y pseudocodigo que representan esta situacion. La clausula "else" nos permite una condicion alternativa, a ejecutar siempre que la condicion principal if() retorne un valor booleano "false".
        ej: 
                let mayorEdad= 18;
                if(mayorEdad >=18){
                        console.log('Es mayor de edad');
                } else{
                        console.log('Es menor de edad');
                }

● if, else, else if: La estructura "else if" brinda la posibilidad que se ejecuten una serie de pasos si una opcion (no la primera) es verdadera. Es posible encadenar tantos else if, como consideremos necesario hacerlo.
        ej: 
                let edad = 26;
                if(edad < 12){
                        alert('Todavia eres muy pequeño');
                }
                else if(edad < 19){
                        alert('Eres un adolescente');
                }
                else if(edad < 35){
                        alert('Aun sigues siendo joven');
                }
                else{
                        alert('Piensa en cuidarte un poco mas')
                }

// Condicionales compuestos
La estructura if, y else…if permiten analizar condiciones simples, y también compuestas. En
este último caso, podemos sumar diferentes condiciones, validando si una de las dos, si las dos, o si ninguna se cumple.
Aquí entran en acción los condicionales compuestos, quienes se combinan con los operadores lógicos && (and), || (or) y eventualmente ! (not)
Por Ej:
        let nombreIngresado= prompt("Ingrese su nombre");
        if((nombreIngresado != "") && (nombreIngresado == "juan" || nombreIngresado == "JUAN"))
        {
                console.log("El nombre ingresado es Juan");
        }
        else{
                console.log("Error: Ingresar nombre valido");
        }

switch: 
La cláusula switch, en JavaScript, es una estructura de control que permite evaluar una expresión y comparar su valor con múltiples casos posibles. Cuando se encuentra un caso que coincide con el valor de la expresión, se ejecuta el bloque de código correspondiente a ese caso.
Es parecido a "if". y se escribe de la siguiente manera

switch (lo que vaya adentro){
        case 1:
        // programo la accion positiva para el caso concreto
                nombreDelDia = 'Lunes';
        break
        
        case 2:
                nombreDelDia = 'Viernes';
        break;
        //Si ninguno de los casos coincide, se puede proporcionar un caso default (por defecto), quese ejecutará si no hay coincidencias. Veamos el siguiente ejemplo:
        default:
        nombreDelDia = 'Dia no valido';
}
Ejemplos de parámetros para un switch - case:
● El estado civil de una persona (soltero, divorciado, viudo,
casado).
● El sexo de una persona (M, F).
● El resultado de un partido (victoria, empate, derrota).
● Los colores del arcoíris (rojo, azul, violeta, y otros).
● Puntos ganados en un partido (3, 1 ó 0).
● Grupos sanguíneos.
● Provincias de Argentina.

// estructura de control "while":
es una accion repetitiva por tantas veces como la accion se cumpla, es decir un bucle
Por Ej:

var resultado = 0;
var tope = 100;
var n = 0;

while(n <= tope){
        resultado += n;
        console.log("resultado vale: " + resultado);
        n++;
}

el do while, es parecido
do {
        consolte.log("resultado vale: " + resultado );
        n++;
} while (n <= tope);

Consola de JavaScript
La consola de JavaScript es una herramienta disponible en todos los navegadores. Sirve para realizar la depuración del código.
Los métodos que explicaremos en los siguientes slides son:
● console.assert. Registra un mensaje y envía una traza de error a la consola si el primer argumento es falso. Este método sirve para evaluar y probar un código mediante los Assertion Test, que son pruebas en las que se evalúa el estado de una variable. A diferencia de un if/else, console.assert es útil solo para el desarrollador. 
● console.clear. Limpia la consola, borra todos los mensajes previos. Es muy útil para cuando tenemos mucho por depurar, incluir este método en el código para hacer más legible el área de depuración de la aplicación web.
● console.count. Registra el número de veces que esta línea ha sido llamada con la etiqueta dada 
● console.countReset. Reinicia el valor del contador para la etiqueta dada
● console.debug Registra un mensaje con el nivel de debug. El nivel debug es un nivel menos grave que el error
● console.time. Una herramienta útil para medir el rendimiento
de un programa es el temporizador. Con el temporizador es posible evaluar cuánto tarda el navegador en ejecutar un código determinado. Con esta información se puede verificar si es necesario cambiar el código para que funcione más rápido

// Objeto de fecha: Clase "Date"
La clase Date es un objeto que forma parte del Core JavaScript. Permite manipular fechas y horas en los desarrollos. Este objeto es instanciable. Esto significa que permite “crear múltiples copias” de ese objeto, de acuerdo a la necesidad de la aplicación. Al ser instanciable, la clase Date() puede ser utilizada para crear múltiples fechas y horas diferentes y, por ejemplo, calcular períodos de tiempo entre estas En este ejemplo de código, vemos la clase Date() instanciada con la fecha indicada en formato Año, Mes, Día

● const fechaInicial = new Date(1996, 7, 14);

Por diferentes nombres de constante, podremos instanciar multiples veces la clase Date(). Con el objetivo de poder calcular la unidad de tiempo que transcurrio entre una fecha y la otra.
● const fechaInicial = new Date(1996, 7, 14);
  const fechaFinal = new Date(2005, 8, 30);

Cada fecha instanciada permite utilizar cada parte que compone su unidad de tiempo, de forma individual. Esto se logra con los diferentes métodos disponibles.
● const fechaInicial = new Date(1996, 7, 14);

● fechaInicial.getDate(): Retorna el día del mes (1-31) de la fecha.
● fechaInicial.getDay(): Retorna el día de la semana (0-6) de la fecha, donde 0 es domingo y 6 es sábado.
● fechaInicial.getMonth(): Retorna el mes (0-11) de la fecha, donde 0 es enero y 11 es diciembre.
● fechaInicial.getFullYear(): Retorna el año (año completo) de la fecha.

El caso de la fecha instanciada corresponde al día 14 de Julio, pero el método getMonth() retorna el número de mes, a través de una estructura interna que asigna el valor 0 para el mes de enero, y el valor 11 para el mes de diciembre. Si necesitamos mostrar el número de mes en la
aplicación, simplemente se le suma 1 al valor que retorna getMonth(). Así, se resuelve el tema.

● const fechaInicial = new Date(1996, 7, 14);
      fechaInicial.getMonth() + 1;

Otra alternativa al ejemplo visto en las últimas diapositivas, es instanciar la fecha utilizando el formato ISO DATE y luego recurrir al método .toLocaleString(), que nos permite formatear el parámetro de salida de la información. Así, se consigue ver el mes correspondiente en formato nombre.

● const fechaInicial = new Date("1996-07-14");

  const opciones = { month: 'long'};
  const fechaFormateada = fechaInicial.toLocaleString('es-AR', opciones);

Este es un ejemplo completo del uso del método .toLocaleString() para obtener: el valor de cada unidad de tiempo de una fecha,
formateado a una configuración regional específica y a un tipo de datos también específico:

●       const fechaInicial = new Date("1996-07-14");
        const opcionesMes = {mont: 'long'};
        const opcionesDia = {weekday: 'long'};
        const opcionesFecha = {day: 'numeric'}
        const opcionesAnio = {year: 'numeric'};

        fechaInicial.toLocalString('es-AR', opcionesMes);
        fechaInicial.toLocalString('es-AR', opcionesDia);
        fechaInicial.toLocalString('es-AR', opcionesFecha);
        fechaInicial.toLocalString('es-AR', opcionesAnio);

.getTime()
El método .getTime() retorna la fecha
instanciada en formato milisegundos. Para calcular un período de tiempo entre dos fechas:
1. Se pueden instanciar, y luego restar la fecha más reciente a la fecha más lejana, mediante la invocación de este método.
2. Luego, a la diferencia retornada en
milisegundos, de la divide por 1000 (1 segundo = 1000 milisegundos). Finalmente, se multiplica por el valor de tiempo máximo de cada unidad de tiempo, hasta llegar a la unidad de tiempo deseada.
3. La diferencia la dividimos por el número de milisegundos en un día (1000 milisegundos por segundo * 60 segundos por minuto * 60 minutos por hora * 24 horas por día), para obtener la diferencia en días.
4. Para calcular la diferencia en semanas, meses y años, podemos usar un enfoque similar pero dividir la diferencia en milisegundos por el número de milisegundos en una semana, mes o año, respectivamente.

let fecha1 = new Date('2023-03-28');
let fecha2 = new Date('2023-04-05');

const diferencia = fecha2.getTime() - fecha1.getTime();
const dias = (diferencia / (1000 * 60 * 60 * 24));

// Arrays:
Los arrays permiten definir, bajo una misma estructura, una serie de valores utiles dentro de nuestra aplicacion. 
En JS se utilizan dos tipos de arrays:
● Arrays de elementos.
● Arrays de objetos.

// innerText = Renderiza como texto 
// innerHTML = Renderiza como HTML 
// para elegir un elemento dentro del decoumento, debemos utilizar = document.querySelector(y el elemento de HTML que queramos seleccionar utilizando '')
// new es para crear un objeto. Date() crea una fecha que es la del sistema operativo

Ante la necesidad de crearu un array que almacene diferentes valores, en cada uno de sus indices, lo mas apropiado sera estructrar un array de obejtos que aporte orden y entendimiento:
Por ej:
        const persona = [ 'Fer', 'Nico', 'July', 'Laura', 'Greta'];

        const pouporri = ['Moon', 21, 75, true, personas];

Cada valor almacenado en un array, obtiene una poscion numerica. Siempre a partir del 0(cero), y se incrementa en un digito por cada nuevo valor contenido en el array.
Por Ej:
        const persona = [ 'Fer', 'Nico', 'July', 'Laura', 'Greta']
        // posicion         0      1        2       3        4

Para leer un valor que este almacenado en el array, simplemente se define el nombre del array y se encierra entre corchetes con el valor numerico de la posicion en la que se encuentra:
Por Ej:
        const persona = [ 'Fer', 'Nico', 'July', 'Laura', 'Greta']
        // posicion         0      1        2       3        4

        persona[3];            //devuelve 'Laura'

Ver contenido del array y depurarlo
Cuando trabajamos con arrays, la forma más efectiva de ver su contenido y depurarlo, es utilizar el objeto console, y su método .table(). Este método representa un array en DevTools > Console, que muestra en formato tabular, y representa sus índices en una segunda columna.
Por Ej:
        const paisesAmericaSur = ["Argentina", "Bolivia", "Brasil", "Chile", "Colombia", "Ecuador"," Guyana", "Paraguay", "Perú", "Surinam", "Uruguay", "Venezuela"];
        
        console.table(paisesAmericaSur);

Contabilizar el total de elementos almacenados
Si se necesita contabilizar el total de elementos que tiene almacenados, se puede recurrir a la propiedad .length.  Retornará un valor numérico, correspondiente al total de elementos almacenados en el array.
Por Ej:
        const paisesAmericaSur = ["Argentina", "Bolivia", "Brasil", "Chile", "Colombia", "Ecuador"," Guyana", "Paraguay", "Perú", "Surinam", "Uruguay", "Venezuela"];
        
        console.log("Total de paises en el arreglo: ", paisesAmericaSur.length);

        //IMPRIMIRA:
        //Total de paises en el arreglo: 12

Métodos de arrays
Además de la propiedad .length, los arreglos cuentan con una serie de métodos que permiten operar con sus valores. A través de ellos, es posible:
● Agregar o quitar elementos.
● Modificar elementos existentes.
● Cambiar elementos del arreglo.
● Ordenar de forma ascendente o descendente.
● Fusionar arreglos.
● Buscar, filtrar, reestructurar, calcular, validar.
● Crear nuevos arreglos a partir de uno
existente.
Los métodos están en constante evolución; por lo tanto, siempre nos conviene seguir las tendencias del mercado para ver aquellos nuevos métodos que surgen y su impacto en el manejo de arrays.

Metodos de Arrays: 

.push:  Agrega un nuevo elemento al final del array. Agrega un nuevo elemento al final del array. Este elemento se debe agregar dentro de los parentesis del metodo.
Por Ej:
       const persona = [ 'Fer', 'Nico', 'July']; 
       persona.push("Laura");
       // El array contendra, ahora: Fer, Nico, July, Laura.

.unshit:  Agrega un nuevo elemento al principio del array. Agrega un elemento nuevo al inicio del array. Este elemento se debe agregar dentro de los parentesis del metodo.
Por Ej:
        const persona = [ 'Fer', 'Nico', 'July', 'Laura'];
        persona.unshift("Greta");
        // El array contendra, ahora: Greta, Fer, Nico, July, Laura.

.pop:  Quita el último elemento del array. No es necesario definir ningun parametro, ya que su accion es automatica
Por Ej:
        const persona = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
        persona.pop();
        //El array contendra, ahora: Greta, Fer, Nico, July.

.shift:  Quita el primer elemento del array. No es necesario definir ninguno parametro, ya que su accion es automatica
Por Ej:
        const persona = [ 'Greta','Fer', 'Nico', 'July'];
        persona.shift();
        //El array contendra, ahora: Fer, Nico, July.

.slice: Crea un nuevo array con elementos de otro array, de forma parcial o total. Recibe dos parametros:
1. El primero, corresponde al índice del array desde donde inicia el proceso mientras que,
2. el segundo parámetro, hasta qué índice debe “rebanar”.
Por Ej:
       const persona = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
       const hijos = persona.slice(2,4);
       //El array 'hijos' contendra: Nico, Laura
El método .slice() puede recibir solo un parámetro. Esta condición sólo debe aplicarse si se desea generar un nuevo array a partir de una posición determinada, hasta el final del array en cuestión.  
Por Ej:
        const persona = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
        const otraPersonas = persona.slice(2);
        //El array 'otrosPersonas' contendra: Nico, July, Laura.

.splice: Quita uno o más elementos del array de cualquier posición. También reemplaza uno o más elementos de un array. Recibe dos parámetros:
1. En el primer parámetro, le indicamos el índice del elemento a remover.
2. En el segundo, cuántos elementos quitaremos.
En el ejemplo del siguiente slide, solo removemos un elemento del array: removemos a ‘Fer’ del array personas.
Si volvemos a consultar el array, veremos que dicho elemento no figura más. Esto hace que .splice() sea definido como un método destructivo, porque modifica el array original.
Por Ej:
        const personas = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
        const persona = personas.splice(1, 1);
        // El array 'persona' contendra: Fer,
        // En el array 'personas' quedaran: Greta, Nico, July, Laura.

El método .splice(), también es utilizado para reemplazar elementos dentro de un array, por un nuevo elemento. En este otro ejemplo, reemplazamos el índice 2 del array “Nico”, por el elemento “Nicolás”. Si queremos “capturar” el elemento reemplazado en el array personas, anteponemos a la cláusula personas.splice(...) una constante, donde quedará capturado el valor que cambiamos: “Nico”.
Por Ej:
        const personas = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
        const persona = personas.splice(2, 1, 'Nicolas');
        // En el array 'personas' quedaran: Greta, Fer, Nicolas, July, Laura
        // En el array 'persona' quedara guardado el dato: Nico.

.indexOf: Permite identificar si un elemento existe, o no, dentro del array. Retorna true o false, según el resultado. Si existe, nos retorna su índice actual; si no, retornará -1. Es una opción muy útil, que se puede aprovechar para identificar el índice de un elemento que deseamos quitar. 
Por Ej: 
        const personas = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
        const idx = persona.indexOf("Laura");
        // idx tendra como valor: 4

En el segundo ejemplo, retorna como resultado -1, porque el nombre a identificar no se encuentra dentro de los elementos del array en cuestión.
Por Ej:
        const personas = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
        const idx = persona.indexOf("Laica");
        // idx tendra como valor: -1
Ejemplo aplicando combinacion de .indexOf y splice:
        const personas = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];

        let aQuitar= prompt("Ingresa el nombre de la persona que deseas quitar: ");

        const resultado = personas.indexOf(aQuitar);

        if (resultado === -1){
                console.warn("La persona a quitar no se encuentra cargada en el array");
        } else{
                personas.splice(aQuitar, 1);
        }
        console.log(resultado);

.includes: Permite identificar si existe o no un elemento dentro de un array. A diferencia de .indexOf(), .includes() retorna solamente true, si existe, o false, si no existe.
Por Ej:
        const personas = [ 'Greta','Fer', 'Nico', 'July', 'Laura' ];
        const idx = persona.includes("Laica");
        // idx tendra como valor: false

.concat:  Agrega un nuevo elemento al final del array. Este método permite concatenar dos arrays en uno solo. En el siguiente ejemplo, se concatenan el array llamado paisesAmericaDelSur con paisesAmericaDelNorte para conformar un nuevo array cuyo nombre es paisesAmerica.
De acuerdo al orden que deseamos para los elementos en el array, es como debemos utilizar los arrays a fusionar. El resultado del ejemplo, tendrá en los primeros lugares del nuevo array, los elementos de paisesAmericaDelSur.
Por Ej: 
        const paisesAmericaSur = ["Argentina ", "Bolivia ", "Brasil ", "Chile ", "Colombia ", "Ecuador "," Guyana ", "Paraguay ", "Perú ", "Surinam ", "Uruguay ", "Venezuela "];
        const paisesAmericaDelNorte = ["Canada ", "Estados Unidos ", "Mexico ", "Alaska"];
        const paisesAmerica= paisesAmericaDelSur.concat(paisesAmericaDelNorte);
        alert(paisesAmerica);

.join:  Agrega un nuevo elemento al principio del array. El método .join() fusiona todos los elementos de un array en una cadena de texto (string). Entre los paréntesis, podemos definir un carácter a usar para separar los elementos unos de otros.
Por Ej:
        const paisesAmericaSur = ["Argentina ", "Bolivia ", "Brasil ", "Chile ", "Colombia ", "Ecuador "," Guyana ", "Paraguay ", "Perú ", "Surinam ", "Uruguay ", "Venezuela "];
        paises.join(" - ");
        // Argentina - Bolivia - Brasil, etc.
        paises.join(", ");
        // Argentina, Bolivia, Brasil, etc
        paises.join(" | ");
        // Argentina | Bolivia | Brasil , etc
        
.sort:  Ordena de forma ascendente los elementos de un array.
.reverse:  Revierte el orden de los elementos de un array.

Para crear una matriz o un array multiple, debo hacer un array de la siguiente manera:
var persona = [
        ["Jose", "Sanchez", 49],
        ["Juana", "Lopez", 23],
        ["Rodrigo", "Perez", 30],
        ["Laura", "Rodriguez", 60],
(para visualizar alguna de las personas dentro del array, deberia hacer lo siguiente)
        console.log("Hola soy: " + persona[3(que es la posicion en la que se encuentra "Laura")][0(Que seria el nombre de Laura)] + " " + persona[3][1] + " y tengo " + persona[3][2] + " años")

];

otra de las formas de ingresar al array es de la siguiente manera, con un bucle, mostrando el nombre de todos
        for (var i = 0; i < persona.length; i ++){
                console.log("Hola soy " + persona[i][0(que vendria a ser la posicion del nombre)])
        };

// OBJETOS
Cuando hablamos de objetos, nos referimos a entidades que representan conceptos reales o abstractos en un formato digital.
Cada objeto tiene un estado y un comportamiento:
● el estado es definido por sus atributos mientras que,
● el comportamiento, se define por sus métodos.
Los objetos se relacionan entre sí a través de sus mensajes y sus métodos y, su uso en el desarrollo de software, permite clarificar de forma efectiva aquellas tareas que definimos en cada línea de código que le da vida a nuestra aplicación.

//Atributos y métodos
Cada objeto tiene un estado y un comportamiento:
● el estado es definido por sus atributos mientras que,
● el comportamiento, se define por sus métodos.
Los objetos se relacionan entre sí a través de sus mensajes y sus métodos

//Propiedades y métodos
Entonces:
● Cada característica (o atributo) que representa a estos objetos dentro del ecosistema de software, suele llamarse propiedad.
● Cada comportamiento de estos objetos, es representado por un método.

//Entidad abstracta
Se puede pensar en, por ejemplo, una computadora. Si bien es algo físico, suele tratarse como una entidad abstracta por sus limitaciones o nicho específico.
Sus características pueden ser:
● Marca.
● Modelo.
● Posee display.
● Posee teclado.
● Posee mouse pad o puntero.
● Sistema operativo.
● Batería.

//Objeto literal 
Cuando se define un objeto literal, éste se debe crear a través de la palabra reservada const.
El nombre que le asignamos suele definirse con su primera inicial en mayúsculas, y debe ser una palabra (sustantivo), expresado en singular.
Su estructura de datos, se debe encerrar entre las llaves de bloque.

Aquí tenemos una representación rápida del objeto literal denominado Persona, con algunos atributos (propiedades), que lo describen.
Cada propiedad llevará un valor asignado. Este valor puede ser expresado en cualquier tipo de dato (string, boolean, number).
Para definir múltiples propiedades, cada una con su valor, utilizamos la coma (,) como separador.
Además de los datos del tipo string y number, podemos agregar a sus propiedades, otros valores como ser un array de elementos, un objeto interno, entre otros tantos.
Por Ej:
        const Persona = {
                nombreCompleto: '',
                edad: 0,
                profesion: '',
                genero: ''
        }

Para leer el valor de alguna de las propiedades, simplemente escribimos Objeto.propiedad. Así se obtiene el valor almacenado.
Para cambiarlo, se utiliza esta misma estructura y se suma el operador de asignación igual (=), más el nuevo valor.
        console.log(Persona.nombreCompleto);

        console.log(Persona.profesion);

        Persona.edad= 21;

// Arreglos de objetos
En JavaScript, es posible crear arrays de objetos literales. Estas estructuras son las más apropiadas para representar un conjunto de objetos usualmente del mismo tipo, y poder trabajar con ellos de forma efectiva.
Este orden permitirá trabajar con los datos de forma prolija, aprovechando métodos de búsqueda y transformación.

// CICLOS DE ITERACION (BUCLES)
JavaScript cuenta cláusulas denominadas ciclos de iteración. Permiten generar tareas de forma repetitiva, de acuerdo a nuestra necesidad.
Los ciclos de iteración, se dividen en dos:
● Ciclos de iteración por conteo.
● Ciclos de iteración por repetición.

// Ciclos de iteración por conteo (for)
Este es el ciclo más conocido por todos: el ciclo for. Este es ideal para poder recorrer un arreglo, o array, y realizar diferentes operaciones sobre los datos, objetos, elementos o cualquier otro conjunto de características que conformen ese arreglo.
Tener presente que, el ciclo for, no nos limita a utilizarlo solo para recorrer arreglos. También se puede implementar para iterar dentro de un rango de valores estáticos, inicial y final, previamente definidos.
Si bien, el uso del ciclo for se puede aprovechar muy bien con arrays, estos cuentan con otros ciclos y métodos más modernos que permiten recorrerlos mucho más rápido.
Estructura paso a paso
El ciclo for cuenta con una estructura configurable a través de sus paréntesis, en la cual recibe tres parámetros:
1. Valor inicial.
2. Condición.
3. Incremento.

Por Ej:

const paisesAmericaSur = ["Argentina", "Bolivia", "Brasil", "Chile", "Colombia", "Ecuador"," Guyana", "Paraguay", "Perú", "Surinam", "Uruguay", "Venezuela"];


    valor incial        condicion           incremento
        |                  |                    |
for(let i = 0; i < paisesAmericaDelSur.length; i++){
        console.log(paisesAmericaDelSur[i]);
}                                       |
                                El valor cambiante de "i", nos permite
                                acceder a cada elemento del array.

1. Valor inicial: se declara una variable,
usualmente i, con el valor inicial 0 (cero).
Si utilizamos el ciclo for para iterar un array,
la variable i será la que tendrá un valor
numérico, cambiante, que podremos utilizar
para acceder a los diferentes elementos del
array que estamos iterando.
2. Análisis de una condición: en el segundo
parámetro, se evalúa una condición; en el
ejemplo del slide anterior, se valida que el
valor que posee i, sea menor al total de
elementos del array. Solo si esta condición se
cumple, se ejecutará el código que se defina
internamente dentro de las llaves de bloque
del ciclo for.
3. Incremento: el tercer parámetro, incrementa
en un dígito el valor que posea i. Esto
reinicia la iteración sobre el arreglo, debiendo
previamente volver a validar la condición
definida como segundo parámetro.
Si la condición del segundo parámetro se
sigue cumpliendo, seguimos iterando el array
y trabajando con el siguiente elemento de
este

// Interrupción del ciclo
Cláusula break
La cláusula break, permite interrumpir el ciclo de
iteración. Por ejemplo, podemos evaluar una
condición determinada y, si esta se cumple,
interrumpirlo.
En nuestro ejemplo, interrumpimos la iteración si
el valor de i, es igual a 4.

        for(let i = 0; i < paisesAmericaDelSur.length; i++){
                console.log(paisesAmericaDelSur[i]);
                if (i === 4){
                        break
                }
        } 

// Cláusula continue
La cláusula continue, permite saltear un paso
del ciclo de iteración.
De igual forma, se puede evaluar una condición
determinada y si, esta se cumple, aplicar
continue

        for(let i = 0; i < paisesAmericaDelSur.length; i++){
                console.log(paisesAmericaDelSur[i]);
                if (i === 4){
                        continue
                }
        } 

// Ciclo for…of
El ciclo for...of ofrece una forma de iterar más simple
que la utilizada con el ciclo for convencional. 
        const paisesAmericaSur = ["Argentina", "Bolivia", "Brasil", "Chile", "Colombia", "Ecuador"," Guyana", "Paraguay", "Perú", "Surinam", "Uruguay", "Venezuela"];
        for (let pais of paisesAmericaDelSur){
                console.log(pais) // mostrara cada elemento contenido en el array
        } 

// Ciclo de iteración por repetición (while)
El ciclo de iteración while repite un bloque de código mientras una condición sea verdadera.
Antes de cada iteración, se evalúa la condición. Si es verdadera, ejecuta el bloque de código; si no, detiene el ciclo.
Siempre debemos tener presente que, este ciclo de iteración, debe controlar dentro del bloque de código el cambio de la condición que lo hace funcionar para, en algún momento, poder interrumpir su ejecución. Si no lo hace, desencadenará un bucle infinito.
Por Ej: 
        let contador = 0
        while (contador < 5){
                console.log("Contador: " + contador)
                contador ++
        }

// Ciclo de iteración por repetición (do-while)
El ciclo de iteración do-while repite un bloque de código mientras una condición sea verdadera.
Aquí, la condición se analiza al final de cada iteración, y se debe contemplar la misma lógica que con el ciclo while, para no generar un loop infinito

Diferencia entre while y do-while
La diferencia de funcionamiento entre los ciclos while y do-while es que, while, puede ejecutarse cero veces, si la condición que evalúa da como resultado false.
En cambio, do-while se ejecutará al menos una vez, dado que la condición que evalúa, lo hace al final de la iteración.

// interrupcion del ciclo
Ambos ciclos de iteración por repetición tienen la posibilidad de integrar, en el bloque de código de ejecución, las cláusulas break y continue (como se vió en el ciclo for, que permite interrumpir o saltear una iteración, en base a una condición válida).

Si se depura una aplicación de software, el método console.table() permite ver tabulados los objetos de este array. Mucho más cómodo y práctico que el clásico método .log(). 

//
Propiedades de acceso a HTML
Las tres propiedades más utilizadas para manipular contenido de elementos HTML son:
● innerText: Permite acceder, desde JS, al texto definido dentro del elemento HTML. Podemos leerlo y/o modificarlo, según nuestro interés.
● textContent: Aporta el mismo resultado que la propiedad anterior, pero textContent es más moderno (llegó en 2015). Su aporte es poder ser más claro, en cuanto al nombre de la propiedad refiere, a diferencia de innerText, el cual solía confundirse su funcionalidad con el nombre de la siguiente propiedad que
veremos.
● innerHTML: Esta propiedad también permite leer el texto de un elemento HTML pero, como su nombre lo indica, realmente está enfocada a que podamos leer/escribir uno o más bloques HTML en etiquetas del tipo contenedor (como por ejemplo, el tag <div>). Cada una aporta lo suyo y se utiliza para determinados casos específicos.

innerHTML
Imaginemos que tenemos un <div>, el cual oficia como tag contenedor de un elemento HTML del tipo <h2> (subtítulo), y otro elemento <p>.
En el <div>, definimos el atributo ID, con un valor para luego enlazarnos desde JS.
Por Ej:
        <div id='contenedor'>
                <h2>Subtitulo del div</h2>
                <p>Otro parrafo de texto dentro de div contenedor</p>
        </div>

        En JS

        const divContenedor = document.getElementById("contenedor");
        console.log(divContenedor.innerText);

innerHTML, a diferencia de las otras propiedades, está pensada para escribir bloques de código HTML desde JS, de forma dinámica. De esta forma, se pueden generar uno o más elementos
HTML en bloque, de forma dinámica, mediante el atributo innerHTML para escribirlos en el
HTML.
Además, podremos concatenar (en el HTML que vamos a generar) variables, constantes o arrays JS, para así poder mostrar su valor en el documento HTML. Esto es lo que se denomina: la Web Dinámica.
Por Ej:
        divContenedor.innerHTML = <h2>Subtitulo generado por JS</h2> +
                                  <p>Y tambien un parrafo generado desde JS</p>

// Query Selector 
CSS utiliza selectores para personalizar los estilos gráficos de los elementos HTML. Estos selectores se dividen en tres tipos principales:
● Elemento.
● ID.
● Clase genérica.
Veamos la tabla en la siguiente diapositiva, con el detalle de cada uno de ellos.

// Manejo de eventos
Aquí tenemos un resumen de las diferentes formas que podemos manejar eventos dentro de una aplicación JavaScript:
1. Atributos on: Forman parte de los elementos HTML. Se conocen con este nombre porque, en el nombre de cada evento, se antepone el término on. Se definen dentro del elemento HTML, y se les asocia una función que se ejecuta ante la ocurrencia de ese evento
2. Eventos on: eventos on Los eventos on son la evolución de los atributos on.
Se manejan íntegramente desde JS. Debemos enlazarnos con un elemento HTML desde JS, y luego utilizar el evento
on, al que le definimos una función como referencia o declaramos una función anónima.
3. Event Listener: eventos on
Los eventos on son la evolución de los atributos on.
Se manejan íntegramente desde JS.
Debemos enlazarnos con un elemento HTML desde JS, y luego utilizar el evento on, al que le definimos una función como referencia o declaramos una función anónima.

// Funciones anónimas
Una función anónima es una forma diferente de escribir una función. Se puede declarar una constante y definir que ésta sea igual a una función anónima, o se puede asignar una función anónima a un evento, sin tener que definir un nombre.

//Asignar múltiples eventos
Cuando tenemos un listado de elementos que repiten su estructura, como ser un listado de productos con un botón de acción para cada uno de ellos, tenemos que pensar en la asignación de eventos múltiples a partir de un mismo código.
Además, es probable que el listado con elementos sea dinámico, por lo tanto, es imposible que desarrollemos un evento dedicado para cada uno de los elementos en cuestión.

Pasos a seguir con el método querySelectorAll
1. El método querySelectorAll es también netamente funcional para llegar al mismo resultado de iteración y generación de múltiples eventos desde un mismo código.
        <button class = "button btn-agregar">+</button>
        const botonesAgregar = document.querySelectorAll("button.btn-agregar");
        for (boton of botonesAgregar){

        }

Funciones
Concepto
En JavaScript, una función es un bloque de
código reutilizable que realiza una tarea
específica. Puede aceptar entradas, llamadas
argumentos, y devuelve un resultado.
Es la forma de organizar y estructurar el código
para poder usar la misma lógica en diferentes
partes de tu programa.
Definición
Para definir una función se usa la palabra
reservada function, se le da un nombre (en el
ejemplo de la derecha, saludar), se abre y cierra
paréntesis ().
Luego, se abren llaves de bloque ({), se escribe el
cuerpo (el código que queremos ejecutar cuando
sea invocada) y, por último, se cierra la llave de
bloque (}).
Por Ej:
        function saludar(){
                alert("Hola! Sou una funcion)
        }

Características de una función
● Debe expresar una acción.
● Debe comenzar con un verbo.
● Debe expresarse en modo imperativo (o sea,
dando una orden).
● Puede ser de nombre simple, o compuesto (en
formato camelCase). 

Ejecución
A diferencia del resto del código que escribimos
hasta aquí, las funciones no se ejecutan si no se
las llama.
Para llamarlas, simplemente escribimos su
nombre junto a los paréntesis, en alguna parte
del archivo JS, y esta será invocada.
Por Ej:
        function saludarUsuario(){
                console.log("Bienvenid@,", username);
        }
        saludarUsuario();

Funciones con parametros
A todas las funciones se les puede
pasar uno o más parámetros. Estos no
son más que variables que existirán
dentro de dicha función, y que acarrean
valores que dicha función deberá
manipular/utilizar internamente.
Así, podemos armar funciones
dinámicas que, siguiendo la lógica que
queramos, pueden generar distintos
resultados al recibir diferentes valores.
Por Ej:
         function saludarUsuario(){
                console.log("Bienvenid@,", username);
        }
        saludarUsuario("July"); //imprime: Bienvenid@, July
        saludarUsuario("Nico"); //imprime: Bienvenid@, Nico
        saludarUsuario("Greta"); //imprime: Bienvenid@, Greta

Definir parámetros descriptivos
La definición del nombre de los parámetros, debe
tener la misma lógica que cuando creamos
variables: poseer nombres descriptivos, que
guíen al desarrollador (nosotros u otro miembro
del equipo), para que sepa al llamar a esta
función, qué valor(es) se espera(n) pasarle
como parámetro(s).
Por Ej: 
        function calcularIVA(importe, valorDeIva){
                console.log("importe final: ", importe * valorDeIva)
        }
        calcularIVA(1500, 1.21);
